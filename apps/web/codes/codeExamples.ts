export const pythonAuthCode =
  'import requests\nimport time\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nimport base64\n\n# Load your private key\nwith open(\'private_key.pem\', \'rb\') as f:\n    private_key = serialization.load_pem_private_key(f.read(), password=None)\n\nemail = "your-email@example.com"\npublic_key = "YOUR_PUBLIC_KEY_PEM"\ntimestamp = str(int(time.time() * 1000))\nmethod = "GET"\npath = "/api/market/quote/AAPL"\n\n# Create signature\nmessage = f"{email}:{timestamp}:{method}:{path}"\nsignature = private_key.sign(\n    message.encode(),\n    padding.PKCS1v15(),\n    hashes.SHA256()\n)\nbase64_signature = base64.b64encode(signature).decode()\n\n# Make request\nheaders = {\n    "x-api-email": email,\n    "x-api-key": public_key,\n    "x-api-signature": base64_signature,\n    "x-api-timestamp": timestamp\n}\n\nresponse = requests.get(f"https://api.bullreckon.com{path}", headers=headers)\nprint(response.json())';

export const jsAuthCode =
  "const crypto = require('crypto');\nconst axios = require('axios');\nconst fs = require('fs');\n\n// Load your private key\nconst privateKey = fs.readFileSync('private_key.pem', 'utf8');\nconst publicKey = fs.readFileSync('public_key.pem', 'utf8');\n\nconst email = 'your-email@example.com';\nconst timestamp = Date.now().toString();\nconst method = 'GET';\nconst path = '/api/market/quote/AAPL';\n\n// Create signature\nconst message = `${email}:${timestamp}:${method}:${path}`;\nconst sign = crypto.createSign('SHA256');\nsign.update(message);\nsign.end();\nconst signature = sign.sign(privateKey, 'base64');\n\n// Make request\nconst headers = {\n  'x-api-email': email,\n  'x-api-key': publicKey,\n  'x-api-signature': signature,\n  'x-api-timestamp': timestamp\n};\n\naxios.get(`https://api.bullreckon.com${path}`, { headers })\n  .then(response => console.log(response.data))\n  .catch(error => console.error(error));";

export const goAuthCode =
  'package main\n\nimport (\n    "crypto"\n    "crypto/rand"\n    "crypto/rsa"\n    "crypto/sha256"\n    "crypto/x509"\n    "encoding/base64"\n    "encoding/pem"\n    "fmt"\n    "io/ioutil"\n    "net/http"\n    "time"\n)\n\nfunc main() {\n    // Load private key\n    privKeyBytes, _ := ioutil.ReadFile("private_key.pem")\n    block, _ := pem.Decode(privKeyBytes)\n    privKey, _ := x509.ParsePKCS1PrivateKey(block.Bytes)\n\n    // Load public key\n    pubKeyBytes, _ := ioutil.ReadFile("public_key.pem")\n    publicKey := string(pubKeyBytes)\n\n    email := "your-email@example.com"\n    timestamp := fmt.Sprintf("%d", time.Now().UnixNano()/1000000)\n    method := "GET"\n    path := "/api/market/quote/AAPL"\n\n    // Create signature\n    message := fmt.Sprintf("%s:%s:%s:%s", email, timestamp, method, path)\n    hashed := sha256.Sum256([]byte(message))\n    signature, _ := rsa.SignPKCS1v15(rand.Reader, privKey, crypto.SHA256, hashed[:])\n    base64Sig := base64.StdEncoding.EncodeToString(signature)\n\n    // Make request\n    client := &http.Client{}\n    req, _ := http.NewRequest(method, "https://api.bullreckon.com"+path, nil)\n    req.Header.Set("x-api-email", email)\n    req.Header.Set("x-api-key", publicKey)\n    req.Header.Set("x-api-signature", base64Sig)\n    req.Header.Set("x-api-timestamp", timestamp)\n\n    resp, _ := client.Do(req)\n    defer resp.Body.Close()\n    \n    body, _ := ioutil.ReadAll(resp.Body)\n    fmt.Println(string(body))\n}';

export const curlAuthCode =
  'curl -X GET "https://api.bullreckon.com/api/market/quote/AAPL" \\\n  -H "x-api-email: your-email@example.com" \\\n  -H "x-api-key: $(cat public_key.pem)" \\\n  -H "x-api-signature: YOUR_BASE64_SIGNATURE" \\\n  -H "x-api-timestamp: 1696512000000"';

export const pythonBotCode =
  'import requests\nimport time\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nimport base64\n\nclass BullReckonAPI:\n    def __init__(self, email, private_key_path, public_key_path):\n        self.email = email\n        self.base_url = "https://api.bullreckon.com"\n        with open(private_key_path, "rb") as f:\n            self.private_key = serialization.load_pem_private_key(f.read(), password=None)\n        with open(public_key_path, "r") as f:\n            self.public_key = f.read()\n    def _sign_request(self, method, path):\n        timestamp = str(int(time.time() * 1000))\n        message = f"{self.email}:{timestamp}:{method}:{path}"\n        signature = self.private_key.sign(\n            message.encode(),\n            padding.PKCS1v15(),\n            hashes.SHA256()\n        )\n        return {\n            "x-api-email": self.email,\n            "x-api-key": self.public_key,\n            "x-api-signature": base64.b64encode(signature).decode(),\n            "x-api-timestamp": timestamp\n        }\n    def get_quote(self, symbol):\n        path = f"/api/market/quote/{symbol}"\n        headers = self._sign_request("GET", path)\n        response = requests.get(f"{self.base_url}{path}", headers=headers)\n        return response.json()\n    def execute_trade(self, symbol, action, quantity, price, script_name, confidence=None, reason=None):\n        path = "/api/trade"\n        headers = self._sign_request("POST", path)\n        data = {\n            "symbol": symbol,\n            "action": action,\n            "quantity": quantity,\n            "price": price,\n            "scriptName": script_name\n        }\n        if confidence:\n            data["confidence"] = confidence\n        if reason:\n            data["reason"] = reason\n        response = requests.post(f"{self.base_url}{path}", headers=headers, json=data)\n        return response.json()\n\n# Example usage\napi = BullReckonAPI("your-email@example.com", "private_key.pem", "public_key.pem")\nquote = api.get_quote("AAPL")\nprint(f"AAPL Price: {quote[\'data\'][\'price\']}")\nif quote["data"]["price"] < 175:\n    trade = api.execute_trade(\n        symbol="AAPL",\n        action="BUY",\n        quantity=10,\n        price=quote["data"]["price"],\n        script_name="my-momentum-strategy",\n        confidence=0.85,\n        reason="Price below target"\n    )\n    print(f"Trade executed: {trade}")';

export const goBotCode =
  'package main\n\nimport (\n    "bytes"\n    "crypto"\n    "crypto/rand"\n    "crypto/rsa"\n    "crypto/sha256"\n    "crypto/x509"\n    "encoding/base64"\n    "encoding/json"\n    "encoding/pem"\n    "fmt"\n    "io/ioutil"\n    "net/http"\n    "time"\n)\n\ntype BullReckonAPI struct {\n    email      string\n    privateKey *rsa.PrivateKey\n    publicKey  string\n    baseURL    string\n}\n\nfunc NewBullReckonAPI(email, privateKeyPath, publicKeyPath string) (*BullReckonAPI, error) {\n    privKeyBytes, _ := ioutil.ReadFile(privateKeyPath)\n    block, _ := pem.Decode(privKeyBytes)\n    privKey, _ := x509.ParsePKCS1PrivateKey(block.Bytes)\n    pubKeyBytes, _ := ioutil.ReadFile(publicKeyPath)\n    return &BullReckonAPI{\n        email:      email,\n        privateKey: privKey,\n        publicKey:  string(pubKeyBytes),\n        baseURL:    "https://api.bullreckon.com",\n    }, nil\n}\n\nfunc (api *BullReckonAPI) signRequest(method, path string) map[string]string {\n    timestamp := fmt.Sprintf("%d", time.Now().UnixNano()/1000000)\n    message := fmt.Sprintf("%s:%s:%s:%s", api.email, timestamp, method, path)\n    hashed := sha256.Sum256([]byte(message))\n    signature, _ := rsa.SignPKCS1v15(rand.Reader, api.privateKey, crypto.SHA256, hashed[:])\n    base64Sig := base64.StdEncoding.EncodeToString(signature)\n    return map[string]string{\n        "x-api-email":     api.email,\n        "x-api-key":       api.publicKey,\n        "x-api-signature": base64Sig,\n        "x-api-timestamp": timestamp,\n    }\n}\n\nfunc (api *BullReckonAPI) GetQuote(symbol string) (map[string]interface{}, error) {\n    path := fmt.Sprintf("/api/market/quote/%s", symbol)\n    headers := api.signRequest("GET", path)\n    client := &http.Client{}\n    req, _ := http.NewRequest("GET", api.baseURL+path, nil)\n    for key, value := range headers {\n        req.Header.Set(key, value)\n    }\n    resp, _ := client.Do(req)\n    defer resp.Body.Close()\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&result)\n    return result, nil\n}\n\nfunc (api *BullReckonAPI) ExecuteTrade(symbol, action string, quantity int, price float64, scriptName string) (map[string]interface{}, error) {\n    path := "/api/trade"\n    headers := api.signRequest("POST", path)\n    data := map[string]interface{}{\n        "symbol":     symbol,\n        "action":     action,\n        "quantity":   quantity,\n        "price":      price,\n        "scriptName": scriptName,\n    }\n    jsonData, _ := json.Marshal(data)\n    client := &http.Client{}\n    req, _ := http.NewRequest("POST", api.baseURL+path, bytes.NewBuffer(jsonData))\n    req.Header.Set("Content-Type", "application/json")\n    for key, value := range headers {\n        req.Header.Set(key, value)\n    }\n    resp, _ := client.Do(req)\n    defer resp.Body.Close()\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&result)\n    return result, nil\n}\n\nfunc main() {\n    api, _ := NewBullReckonAPI("your-email@example.com", "private_key.pem", "public_key.pem")\n    quote, _ := api.GetQuote("AAPL")\n    fmt.Printf("AAPL Quote: %v\\n", quote)\n    trade, _ := api.ExecuteTrade("AAPL", "BUY", 10, 175.50, "my-momentum-strategy")\n    fmt.Printf("Trade: %v\\n", trade)\n}';

export const pythonBacktestCode =
  '# Run backtest\nbacktest_data = {\n    "strategyName": "momentum-rsi-strategy",\n    "symbol": "AAPL",\n    "startDate": "2023-01-01",\n    "endDate": "2023-12-31",\n    "initialCapital": 10000,\n    "parameters": {\n        "rsiPeriod": 14,\n        "oversoldThreshold": 30,\n        "overboughtThreshold": 70\n    }\n}\n\npath = "/api/backtest"\nheaders = api._sign_request("POST", path)\nresponse = requests.post(f"{api.base_url}{path}", headers=headers, json=backtest_data)\nresult = response.json()\n\nprint(f"Total Return: {result[\'data\'][\'metrics\'][\'totalReturnPercent\']}%")\nprint(f"Sharpe Ratio: {result[\'data\'][\'metrics\'][\'sharpeRatio\']}")\nprint(f"Win Rate: {result[\'data\'][\'metrics\'][\'winRate\']}%")';

export const goBacktestCode =
  'func (api *BullReckonAPI) RunBacktest(strategyName, symbol, startDate, endDate string, initialCapital float64, params map[string]interface{}) (map[string]interface{}, error) {\n    path := "/api/backtest"\n    headers := api.signRequest("POST", path)\n    data := map[string]interface{}{\n        "strategyName":   strategyName,\n        "symbol":         symbol,\n        "startDate":      startDate,\n        "endDate":        endDate,\n        "initialCapital": initialCapital,\n        "parameters":     params,\n    }\n    jsonData, _ := json.Marshal(data)\n    client := &http.Client{}\n    req, _ := http.NewRequest("POST", api.baseURL+path, bytes.NewBuffer(jsonData))\n    req.Header.Set("Content-Type", "application/json")\n    for key, value := range headers {\n        req.Header.Set(key, value)\n    }\n    resp, _ := client.Do(req)\n    defer resp.Body.Close()\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&result)\n    return result, nil\n}\n\n// Usage\nparams := map[string]interface{}{\n    "rsiPeriod":           14,\n    "oversoldThreshold":   30,\n    "overboughtThreshold": 70,\n}\nresult, _ := api.RunBacktest("momentum-rsi-strategy", "AAPL", "2023-01-01", "2023-12-31", 10000, params)\nmetrics := result["data"].(map[string]interface{})["metrics"].(map[string]interface{})\nfmt.Printf("Total Return: %.2f%%\\n", metrics["totalReturnPercent"])\nfmt.Printf("Sharpe Ratio: %.2f\\n", metrics["sharpeRatio"])\n';
